{"ast":null,"code":"import { _ as _inherits, a as _classCallCheck, b as _callSuper, c as _assertThisInitialized, d as _createClass } from './inherits-8fbdedb5.esm.js';\nimport { _ as _defineProperty, a as _objectSpread2 } from './index-29acc883.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, i as identity, c as createNormalizationFunction, g as getPixelRatio, v as validateGraph, a as createElement, b as graphExtent, m as matrixFromCamera, z as zIndexOrdering, d as getMatrixImpact, f as multiplyVec2 } from './normalization-8e7b2e97.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-2f6d17f0.esm.js';\nimport { resolveSettings, validateSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { e as extend } from './data-31990a76.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n *\n * @constructor\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Camera, _TypedEventEmitter);\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"x\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"y\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"angle\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"ratio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"minRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"maxRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"nextFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"previousState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n  _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     *\n     * @return {Camera}\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     *\n     * @param ratio\n     * @return {number}\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     *\n     * @param state\n     * @return {object}\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (typeof state.x === \"number\") validatedState.x = state.x;\n      if (typeof state.y === \"number\") validatedState.y = state.y;\n      if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n      if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      return validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // TODO: update by function\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     *\n     * @param  {function} updater - Updated function taking current state and\n     *                              returning next state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}                    state      - State to reach eventually.\n     * @param  {object}                    opts       - Options:\n     * @param  {number}                      duration - Duration of the animation.\n     * @param  {string | number => number}   easing   - Easing function or name of an existing one\n     * @param  {function}                  callback   - Callback\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state, opts, callback) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      var options = Object.assign({}, ANIMATE_DEFAULTS, opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio / factorOrOptions\n        });else this.animate({\n          ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio * factorOrOptions\n        });else this.animate({\n          ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n  return Camera;\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n  return {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    original: e\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Captor, _TypedEventEmitter);\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  return _createClass(Captor);\n}(TypedEventEmitter);\n\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT$1 = 100;\nvar DRAGGED_EVENTS_TOLERANCE = 3;\nvar MOUSE_INERTIA_DURATION = 200;\nvar MOUSE_INERTIA_RATIO = 3;\nvar MOUSE_ZOOM_DURATION = 250;\nvar ZOOMING_RATIO = 1.7;\nvar DOUBLE_CLICK_TIMEOUT = 300;\nvar DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nvar DOUBLE_CLICK_ZOOMING_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"draggedEvents\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"downStartTime\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseX\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseY\", null);\n    _defineProperty(_assertThisInitialized(_this), \"isMouseDown\", false);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"movingTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"startCameraState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"clicks\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"doubleClickTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"currentWheelDirection\", 0);\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleRightClick = _this.handleRightClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleEnter = _this.handleEnter.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseleave\", _this.handleLeave, false);\n    container.addEventListener(\"mouseenter\", _this.handleEnter, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, DOUBLE_CLICK_TIMEOUT);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: DOUBLE_CLICK_ZOOMING_DURATION\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, DRAG_TIMEOUT$1);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) return;\n\n      // Default behavior\n      var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Cancel events that are too close too each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: MOUSE_ZOOM_DURATION\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }]);\n  return MouseCaptor;\n}(Captor);\nvar DRAG_TIMEOUT = 200;\nvar TOUCH_INERTIA_RATIO = 3;\nvar TOUCH_INERTIA_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(TouchCaptor, _Captor);\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"hasMoved\", false);\n    _defineProperty(_assertThisInitialized(_this), \"touchMode\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"startTouchesPositions\", []);\n    _this.handleStart = _this.handleStart.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, false);\n    container.addEventListener(\"touchend\", _this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n    container.addEventListener(\"touchmove\", _this.handleMove, false);\n    return _this;\n  }\n  _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchend\", this.handleLeave);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      container.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"dispatchRelatedMouseEvent\",\n    value: function dispatchRelatedMouseEvent(type, e, touch, emitter) {\n      var mousePosition = touch || e.touches[0];\n      var mouseEvent = new MouseEvent(type, {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey\n      });\n      mouseEvent.isFakeSigmaMouseEvent = true;\n      (emitter || this.container).dispatchEvent(mouseEvent);\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n        this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n        // ... and only click if no move was made\n        if (!this.hasMoved) {\n          this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n        }\n      }\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          // TODO\n          // Dispatch event\n\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: TOUCH_INERTIA_DURATION,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n\n      // If a move was initiated at some point and we get back to startpoint,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return position.x !== startPosition.x || position.y !== startPosition.y;\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, DRAG_TIMEOUT);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {};\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height);\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n      this.emit(\"touchmove\", getTouchCoords(e, this.container));\n    }\n  }]);\n  return TouchCaptor;\n}(Captor);\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n  return LabelGrid;\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Sigma, _TypedEventEmitter);\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_assertThisInitialized(_this), \"elements\", {});\n    _defineProperty(_assertThisInitialized(_this), \"canvasContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"webGLContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"pickingLayers\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"textures\", {});\n    _defineProperty(_assertThisInitialized(_this), \"frameBuffers\", {});\n    _defineProperty(_assertThisInitialized(_this), \"activeListeners\", {});\n    _defineProperty(_assertThisInitialized(_this), \"labelGrid\", new LabelGrid());\n    _defineProperty(_assertThisInitialized(_this), \"nodeDataCache\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_assertThisInitialized(_this), \"nodeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"matrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"invMatrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"correctionRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"customBBox\", null);\n    _defineProperty(_assertThisInitialized(_this), \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_assertThisInitialized(_this), \"graphToViewportRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"itemIDsIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeIndices\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_assertThisInitialized(_this), \"width\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"height\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"pixelRatio\", getPixelRatio());\n    _defineProperty(_assertThisInitialized(_this), \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_assertThisInitialized(_this), \"displayedNodeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"displayedEdgeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"highlightedNodes\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"hoveredNode\", null);\n    _defineProperty(_assertThisInitialized(_this), \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_assertThisInitialized(_this), \"renderFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"needToProcess\", false);\n    _defineProperty(_assertThisInitialized(_this), \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_assertThisInitialized(_this), \"nodePrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeHoverPrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this.frameBuffers.nodes, _assertThisInitialized(_this));\n      var NodeHoverProgram = NodeProgramClass;\n      if (type in _this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n      }\n      _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, null, _assertThisInitialized(_this));\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];\n      _this.edgePrograms[_type] = new EdgeProgramClass(_this.webGLContexts.edges, _this.frameBuffers.edges, _assertThisInitialized(_this));\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  _createClass(Sigma, [{\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var canvas = createElement(\"canvas\", {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      this.elements[id] = canvas;\n      this.container.appendChild(canvas);\n      return canvas;\n    }\n\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var canvas = this.createCanvas(id);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Internal function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id, options) {\n      var canvas = this.createCanvas(id);\n      if (options !== null && options !== void 0 && options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options || {});\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options !== null && options !== void 0 && options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(e);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(e) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createMouseListener = function createMouseListener(eventType) {\n        return function (e) {\n          var baseEvent = {\n            event: e,\n            preventSigmaDefault: function preventSigmaDefault() {\n              e.preventSigmaDefault();\n            }\n          };\n          var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n          var nodeAtPosition = isFakeSigmaMouseEvent ? _this3.getNodeAtPosition(e) : _this3.hoveredNode;\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(e.x, e.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createMouseListener(\"click\");\n      this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n      this.activeListeners.handleDown = createMouseListener(\"down\");\n      this.activeListeners.handleUp = createMouseListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n      // TODO\n      // Deal with Touch captor events\n\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate() {\n      this.camera.minRatio = this.settings.minCameraRatio;\n      this.camera.maxRatio = this.settings.maxCameraRatio;\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this6 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this6.nodeDataCache[node];\n        var _this6$framedGraphToV = _this6.framedGraphToViewport(data),\n          x = _this6$framedGraphToV.x,\n          y = _this6$framedGraphToV.y;\n        var size = _this6.scaleSize(data.size);\n        var defaultDrawNodeHover = _this6.settings.defaultDrawNodeHover;\n        var nodeProgram = _this6.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this6.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this6.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this6.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this6.nodeDataCache[node];\n        _this6.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      for (var _type3 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type3];\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          pixelRatio: this.pixelRatio,\n          cameraAngle: this.camera.angle,\n          zoomRatio: this.camera.ratio,\n          sizeRatio: 1 / this.scaleSize(),\n          correctionRatio: this.correctionRatio,\n          downSizingRatio: this.pickingDownSizingRatio\n        });\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this7.renderHighlightedNodes();\n        _this7.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this8.emit(\"afterRender\");\n        return _this8;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this8.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getSetting(\"stagePadding\") || 0;\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = {\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio\n      };\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type4 in this.edgePrograms) {\n          var _program = this.edgePrograms[_type4];\n          _program.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.settings[key] = updater(this.settings[key]);\n      validateSettings(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (previousWidth === this.width && previousHeight === this.height) return this;\n      this.emit(\"resize\");\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this9 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this9.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this9.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this10 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this10.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n\n      // TODO: handle max zoom\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      // TODO: reduce relative margin?\n      var marginX = 0 * this.width / 8,\n        marginY = 0 * this.height / 8;\n      var p1 = this.viewportToFramedGraph({\n          x: 0 - marginX,\n          y: 0 - marginY\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width + marginX,\n          y: 0 - marginY\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height + marginY\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying WebGL contexts\n      for (var id in this.webGLContexts) {\n        var _context$getExtension;\n        var context = this.webGLContexts[id];\n        (_context$getExtension = context.getExtension(\"WEBGL_lose_context\")) === null || _context$getExtension === void 0 || _context$getExtension.loseContext();\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type5 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type5].kill();\n      }\n      for (var _type6 in this.edgePrograms) {\n        this.edgePrograms[_type6].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      return _objectSpread2({}, this.elements);\n    }\n  }]);\n  return Sigma;\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };","map":{"version":3,"names":["_","_inherits","a","_classCallCheck","b","_callSuper","c","_assertThisInitialized","d","_createClass","_defineProperty","_objectSpread2","TypedEventEmitter","A","ANIMATE_DEFAULTS","e","easings","i","identity","createNormalizationFunction","g","getPixelRatio","v","validateGraph","createElement","graphExtent","m","matrixFromCamera","z","zIndexOrdering","getMatrixImpact","f","multiplyVec2","_slicedToArray","_arrayLikeToArray","_unsupportedIterableToArray","getPixelColor","colorToIndex","resolveSettings","validateSettings","extend","DEFAULT_ZOOMING_RATIO","Camera","_TypedEventEmitter","_this","previousState","getState","key","value","enable","enabled","disable","x","y","angle","ratio","hasState","state","getPreviousState","getBoundedRatio","r","minRatio","Math","max","maxRatio","min","validateState","validatedState","isAnimated","nextFrame","setState","validState","emit","updateState","updater","animate","opts","callback","_this2","options","Object","assign","easing","start","Date","now","initialState","fn","t","duration","animationCallback","call","undefined","coefficient","newState","requestAnimationFrame","cancelAnimationFrame","animatedZoom","factorOrOptions","factor","animatedUnzoom","animatedReset","copy","from","camera","getPosition","dom","bbox","getBoundingClientRect","clientX","left","clientY","top","getMouseCoords","res","sigmaDefaultPrevented","preventSigmaDefault","original","getWheelCoords","delta","getWheelDelta","MAX_TOUCHES","getTouchesArray","touches","arr","l","length","push","getTouchCoords","map","touch","deltaY","detail","Error","Captor","container","renderer","DRAG_TIMEOUT$1","DRAGGED_EVENTS_TOLERANCE","MOUSE_INERTIA_DURATION","MOUSE_INERTIA_RATIO","MOUSE_ZOOM_DURATION","ZOOMING_RATIO","DOUBLE_CLICK_TIMEOUT","DOUBLE_CLICK_ZOOMING_RATIO","DOUBLE_CLICK_ZOOMING_DURATION","MouseCaptor","_Captor","handleClick","bind","handleRightClick","handleDown","handleUp","handleMove","handleWheel","handleLeave","handleEnter","addEventListener","document","kill","removeEventListener","clicks","doubleClickTimeout","clearTimeout","handleDoubleClick","setTimeout","draggedEvents","preventDefault","stopPropagation","mouseCoords","getCamera","newRatio","getViewportZoomedState","button","startCameraState","_getPosition","lastMouseX","lastMouseY","downStartTime","isMouseDown","_this3","movingTimeout","_getPosition2","cameraState","previousCameraState","isMoving","shouldRefresh","refresh","_this4","target","window","_getPosition3","eX","eY","lastMouse","viewportToFramedGraph","mouse","offsetX","offsetY","_this5","wheelCoords","ratioDiff","wheelDirection","currentWheelDirection","lastWheelTriggerTime","DRAG_TIMEOUT","TOUCH_INERTIA_RATIO","TOUCH_INERTIA_DURATION","TouchCaptor","handleStart","getDimensions","width","offsetWidth","height","offsetHeight","dispatchRelatedMouseEvent","type","emitter","mousePosition","mouseEvent","MouseEvent","altKey","ctrlKey","isFakeSigmaMouseEvent","dispatchEvent","touchMode","startTouchesPositions","lastTouches","lastTouchesPositions","_this$startTouchesPos","_this$startTouchesPos2","x0","y0","_this$startTouchesPos3","x1","y1","startTouchesAngle","atan2","startTouchesDistance","sqrt","pow","hasMoved","touchesPositions","some","position","idx","startPosition","_this$renderer$viewpo","xStart","yStart","_this$renderer$viewpo2","newCameraState","_touchesPositions$","_touchesPositions$2","angleDiff","hypot","dimensions","touchGraphPosition","smallestDimension","dx","dy","_x","_y","_ref","cos","sin","_arrayWithoutHoles","Array","isArray","_iterableToArray","iter","Symbol","iterator","_nonIterableSpread","TypeError","_toConsumableArray","LabelCandidate","size","compare","first","second","LabelGrid","resizeAndClear","cellSize","columns","ceil","rows","cells","getIndex","pos","xIndex","floor","yIndex","add","candidate","index","cell","organize","k","sort","getLabelsToDisplay","density","cellArea","scaledCellArea","scaledDensity","labelsToDisplayPerCell","labels","edgeLabelsToDisplayFromNodes","params","graph","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","forEachEdge","edge","source","has","X_LABEL_MARGIN","Y_LABEL_MARGIN","hasOwnProperty","prototype","applyNodeDefaults","settings","data","concat","color","defaultNodeColor","label","hidden","highlighted","forceLabel","defaultNodeType","zIndex","applyEdgeDefaults","_key","defaultEdgeColor","defaultEdgeType","Sigma$1","Sigma","arguments","Set","Infinity","pixelRatio","HTMLElement","createWebGLContext","picking","enableEdgeEvents","createCanvasContext","resize","nodeProgramClasses","NodeProgramClass","nodePrograms","webGLContexts","nodes","frameBuffers","NodeHoverProgram","nodeHoverProgramClasses","nodeHoverPrograms","hoverNodes","_type","edgeProgramClasses","EdgeProgramClass","edgePrograms","edges","bindCameraHandlers","mouseCaptor","elements","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","createCanvas","id","canvas","appendChild","contextOptions","preserveDrawingBuffer","antialias","canvasContexts","getContext","remove","context","gl","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pickingLayers","newFrameBuffer","createFramebuffer","resetWebGLTexture","frameBuffer","currentTexture","textures","deleteTexture","pickingTexture","createTexture","bindFramebuffer","FRAMEBUFFER","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","framebufferTexture2D","COLOR_ATTACHMENT0","activeListeners","scheduleRender","on","unbindCameraHandlers","removeListener","getNodeAtPosition","pickingDownSizingRatio","apply","itemAt","itemIDsIndex","handleResize","scheduleRefresh","baseEvent","event","nodeToHover","nodeDataCache","node","scheduleHighlightedNodesRender","edgeToHover","getEdgeAtPoint","hoveredEdge","createMouseListener","eventType","nodeAtPosition","LAYOUT_IMPACTING_FIELDS","eachNodeAttributesUpdatedGraphUpdate","_e$hints","updatedFields","hints","attributes","forEachNode","updateNode","layoutChanged","partialGraph","skipIndexation","schedule","eachEdgeAttributesUpdatedGraphUpdate","_e$hints2","updateEdge","includes","addNodeGraphUpdate","payload","addNode","updateNodeGraphUpdate","dropNodeGraphUpdate","removeNode","addEdgeGraphUpdate","addEdge","updateEdgeGraphUpdate","dropEdgeGraphUpdate","removeEdge","clearEdgesGraphUpdate","clearEdgeState","clearEdgeIndices","clearGraphUpdate","clearNodeState","clearNodeIndices","unbindGraphHandlers","process","nodeExtent","normalizationFunction","customBBox","nullCamera","nullCameraMatrix","getGraphDimensions","getSetting","labelGrid","labelGridCellSize","nodesPerPrograms","nodeIndices","edgeIndices","incrID","attrs","getNodeAttributes","applyTo","framedGraphToViewport","matrix","reallocate","nodeZExtent","_i","_l","_node","_data","addNodeToProgram","edgesPerPrograms","_i2","_l2","_data2","edgeDataCache","edgeZExtent","_type2","_i3","_l3","_edge","_data3","addEdgeToProgram","minCameraRatio","maxCameraRatio","renderLabels","labelsToDisplay","labelDensity","nodesWithForcedLabels","_this$framedGraphToVi","scaleSize","labelRenderedSizeThreshold","defaultDrawNodeLabel","nodeProgram","drawLabel","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgesWithForcedLabels","displayedLabels","extremities","sourceData","targetData","edgeData","defaultDrawEdgeLabel","edgeProgram","displayedEdgeLabels","renderHighlightedNodes","_this6","hovers","render","_this6$framedGraphToV","defaultDrawNodeHover","drawHover","nodesToRender","forEach","clear","COLOR_BUFFER_BIT","_type3","program","cameraAngle","zoomRatio","sizeRatio","correctionRatio","downSizingRatio","_this7","renderHighlightedNodesFrame","renderFrame","_this8","exitRender","needToProcess","layer","order","moving","viewportDimensions","graphDimensions","padding","invMatrix","graphToViewportRatio","getGraphToViewportRatio","hideEdgesOnMove","_type4","_program","hideLabelsOnMove","attr","nodeReducer","nodeProgramIndex","getEdgeAttributes","edgeReducer","edgeProgramIndex","clearIndices","clearState","fingerprint","setCamera","getContainer","getGraph","setGraph","checkEdgesEventsFrame","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getNodeDisplayedLabels","getEdgeDisplayedLabels","getSettings","setSetting","updateSetting","previousWidth","previousHeight","allowInvalidContainer","element","style","_id","setAttribute","scale","_id2","viewport","WebGLRenderingContext","_this9","fullRefresh","_opts$partialGraph","_opts$partialGraph2","programIndex","_i4","_l4","_programIndex","_this10","viewportTarget","_this$camera$getState","center","graphMousePosition","graphCenterPosition","viewRectangle","marginX","marginY","p1","p2","h","x2","y2","coordinates","override","recomputeMatrix","viewportPos","isNaN","viewportToGraph","viewportPoint","inverse","graphToViewport","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","viewportD","getBBox","getCustomBBox","setCustomBBox","removeAllListeners","_context$getExtension","getExtension","loseContext","firstChild","removeChild","_type5","_type6","cameraRatio","zoomToSizeRatioFunction","getCanvases","default"],"sources":["C:/ders2/a python/sigma/app/application/node_modules/sigma/dist/sigma.esm.js"],"sourcesContent":["import { _ as _inherits, a as _classCallCheck, b as _callSuper, c as _assertThisInitialized, d as _createClass } from './inherits-8fbdedb5.esm.js';\nimport { _ as _defineProperty, a as _objectSpread2 } from './index-29acc883.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, i as identity, c as createNormalizationFunction, g as getPixelRatio, v as validateGraph, a as createElement, b as graphExtent, m as matrixFromCamera, z as zIndexOrdering, d as getMatrixImpact, f as multiplyVec2 } from './normalization-8e7b2e97.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-2f6d17f0.esm.js';\nimport { resolveSettings, validateSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { e as extend } from './data-31990a76.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n *\n * @constructor\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Camera, _TypedEventEmitter);\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"x\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"y\", 0.5);\n    _defineProperty(_assertThisInitialized(_this), \"angle\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"ratio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"minRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"maxRatio\", null);\n    _defineProperty(_assertThisInitialized(_this), \"nextFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"previousState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n  _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     *\n     * @return {Camera}\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     *\n     * @param ratio\n     * @return {number}\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     *\n     * @param state\n     * @return {object}\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (typeof state.x === \"number\") validatedState.x = state.x;\n      if (typeof state.y === \"number\") validatedState.y = state.y;\n      if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n      if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      return validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // TODO: update by function\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     *\n     * @param  {function} updater - Updated function taking current state and\n     *                              returning next state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}                    state      - State to reach eventually.\n     * @param  {object}                    opts       - Options:\n     * @param  {number}                      duration - Duration of the animation.\n     * @param  {string | number => number}   easing   - Easing function or name of an existing one\n     * @param  {function}                  callback   - Callback\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state, opts, callback) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      var options = Object.assign({}, ANIMATE_DEFAULTS, opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio / factorOrOptions\n        });else this.animate({\n          ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio * factorOrOptions\n        });else this.animate({\n          ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n  return Camera;\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n  return {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    original: e\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Captor, _TypedEventEmitter);\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  return _createClass(Captor);\n}(TypedEventEmitter);\n\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT$1 = 100;\nvar DRAGGED_EVENTS_TOLERANCE = 3;\nvar MOUSE_INERTIA_DURATION = 200;\nvar MOUSE_INERTIA_RATIO = 3;\nvar MOUSE_ZOOM_DURATION = 250;\nvar ZOOMING_RATIO = 1.7;\nvar DOUBLE_CLICK_TIMEOUT = 300;\nvar DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nvar DOUBLE_CLICK_ZOOMING_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"draggedEvents\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"downStartTime\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseX\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastMouseY\", null);\n    _defineProperty(_assertThisInitialized(_this), \"isMouseDown\", false);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"movingTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"startCameraState\", null);\n    _defineProperty(_assertThisInitialized(_this), \"clicks\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"doubleClickTimeout\", null);\n    _defineProperty(_assertThisInitialized(_this), \"currentWheelDirection\", 0);\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleRightClick = _this.handleRightClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleEnter = _this.handleEnter.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseleave\", _this.handleLeave, false);\n    container.addEventListener(\"mouseenter\", _this.handleEnter, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, DOUBLE_CLICK_TIMEOUT);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: DOUBLE_CLICK_ZOOMING_DURATION\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, DRAG_TIMEOUT$1);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) return;\n\n      // Default behavior\n      var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Cancel events that are too close too each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: MOUSE_ZOOM_DURATION\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }]);\n  return MouseCaptor;\n}(Captor);\n\nvar DRAG_TIMEOUT = 200;\nvar TOUCH_INERTIA_RATIO = 3;\nvar TOUCH_INERTIA_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  _inherits(TouchCaptor, _Captor);\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_assertThisInitialized(_this), \"enabled\", true);\n    _defineProperty(_assertThisInitialized(_this), \"isMoving\", false);\n    _defineProperty(_assertThisInitialized(_this), \"hasMoved\", false);\n    _defineProperty(_assertThisInitialized(_this), \"touchMode\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"startTouchesPositions\", []);\n    _this.handleStart = _this.handleStart.bind(_assertThisInitialized(_this));\n    _this.handleLeave = _this.handleLeave.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, false);\n    container.addEventListener(\"touchend\", _this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n    container.addEventListener(\"touchmove\", _this.handleMove, false);\n    return _this;\n  }\n  _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchend\", this.handleLeave);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      container.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"dispatchRelatedMouseEvent\",\n    value: function dispatchRelatedMouseEvent(type, e, touch, emitter) {\n      var mousePosition = touch || e.touches[0];\n      var mouseEvent = new MouseEvent(type, {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey\n      });\n      mouseEvent.isFakeSigmaMouseEvent = true;\n      (emitter || this.container).dispatchEvent(mouseEvent);\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n        this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n        // ... and only click if no move was made\n        if (!this.hasMoved) {\n          this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n        }\n      }\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          // TODO\n          // Dispatch event\n\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: TOUCH_INERTIA_DURATION,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n\n      // If a move was initiated at some point and we get back to startpoint,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return position.x !== startPosition.x || position.y !== startPosition.y;\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, DRAG_TIMEOUT);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {};\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height);\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n      this.emit(\"touchmove\", getTouchCoords(e, this.container));\n    }\n  }]);\n  return TouchCaptor;\n}(Captor);\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n  return LabelGrid;\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  _inherits(Sigma, _TypedEventEmitter);\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_assertThisInitialized(_this), \"elements\", {});\n    _defineProperty(_assertThisInitialized(_this), \"canvasContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"webGLContexts\", {});\n    _defineProperty(_assertThisInitialized(_this), \"pickingLayers\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"textures\", {});\n    _defineProperty(_assertThisInitialized(_this), \"frameBuffers\", {});\n    _defineProperty(_assertThisInitialized(_this), \"activeListeners\", {});\n    _defineProperty(_assertThisInitialized(_this), \"labelGrid\", new LabelGrid());\n    _defineProperty(_assertThisInitialized(_this), \"nodeDataCache\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_assertThisInitialized(_this), \"nodeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeProgramIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_assertThisInitialized(_this), \"matrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"invMatrix\", identity());\n    _defineProperty(_assertThisInitialized(_this), \"correctionRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"customBBox\", null);\n    _defineProperty(_assertThisInitialized(_this), \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_assertThisInitialized(_this), \"graphToViewportRatio\", 1);\n    _defineProperty(_assertThisInitialized(_this), \"itemIDsIndex\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeIndices\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_assertThisInitialized(_this), \"width\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"height\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"pixelRatio\", getPixelRatio());\n    _defineProperty(_assertThisInitialized(_this), \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_assertThisInitialized(_this), \"displayedNodeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"displayedEdgeLabels\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"highlightedNodes\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"hoveredNode\", null);\n    _defineProperty(_assertThisInitialized(_this), \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_assertThisInitialized(_this), \"renderFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_assertThisInitialized(_this), \"needToProcess\", false);\n    _defineProperty(_assertThisInitialized(_this), \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_assertThisInitialized(_this), \"nodePrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"nodeHoverPrograms\", {});\n    _defineProperty(_assertThisInitialized(_this), \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this.frameBuffers.nodes, _assertThisInitialized(_this));\n      var NodeHoverProgram = NodeProgramClass;\n      if (type in _this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n      }\n      _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, null, _assertThisInitialized(_this));\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];\n      _this.edgePrograms[_type] = new EdgeProgramClass(_this.webGLContexts.edges, _this.frameBuffers.edges, _assertThisInitialized(_this));\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _assertThisInitialized(_this));\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  _createClass(Sigma, [{\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var canvas = createElement(\"canvas\", {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      this.elements[id] = canvas;\n      this.container.appendChild(canvas);\n      return canvas;\n    }\n\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var canvas = this.createCanvas(id);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Internal function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id, options) {\n      var canvas = this.createCanvas(id);\n      if (options !== null && options !== void 0 && options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options || {});\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options !== null && options !== void 0 && options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(e);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(e) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createMouseListener = function createMouseListener(eventType) {\n        return function (e) {\n          var baseEvent = {\n            event: e,\n            preventSigmaDefault: function preventSigmaDefault() {\n              e.preventSigmaDefault();\n            }\n          };\n          var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n          var nodeAtPosition = isFakeSigmaMouseEvent ? _this3.getNodeAtPosition(e) : _this3.hoveredNode;\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(e.x, e.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createMouseListener(\"click\");\n      this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n      this.activeListeners.handleDown = createMouseListener(\"down\");\n      this.activeListeners.handleUp = createMouseListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n      // TODO\n      // Deal with Touch captor events\n\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate() {\n      this.camera.minRatio = this.settings.minCameraRatio;\n      this.camera.maxRatio = this.settings.maxCameraRatio;\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this6 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this6.nodeDataCache[node];\n        var _this6$framedGraphToV = _this6.framedGraphToViewport(data),\n          x = _this6$framedGraphToV.x,\n          y = _this6$framedGraphToV.y;\n        var size = _this6.scaleSize(data.size);\n        var defaultDrawNodeHover = _this6.settings.defaultDrawNodeHover;\n        var nodeProgram = _this6.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this6.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this6.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this6.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this6.nodeDataCache[node];\n        _this6.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      for (var _type3 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type3];\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          pixelRatio: this.pixelRatio,\n          cameraAngle: this.camera.angle,\n          zoomRatio: this.camera.ratio,\n          sizeRatio: 1 / this.scaleSize(),\n          correctionRatio: this.correctionRatio,\n          downSizingRatio: this.pickingDownSizingRatio\n        });\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this7.renderHighlightedNodes();\n        _this7.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this8.emit(\"afterRender\");\n        return _this8;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this8.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getSetting(\"stagePadding\") || 0;\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = {\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio\n      };\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type4 in this.edgePrograms) {\n          var _program = this.edgePrograms[_type4];\n          _program.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.settings[key] = updater(this.settings[key]);\n      validateSettings(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (previousWidth === this.width && previousHeight === this.height) return this;\n      this.emit(\"resize\");\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this9 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this9.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this9.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this10 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this10.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n\n      // TODO: handle max zoom\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      // TODO: reduce relative margin?\n      var marginX = 0 * this.width / 8,\n        marginY = 0 * this.height / 8;\n      var p1 = this.viewportToFramedGraph({\n          x: 0 - marginX,\n          y: 0 - marginY\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width + marginX,\n          y: 0 - marginY\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height + marginY\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying WebGL contexts\n      for (var id in this.webGLContexts) {\n        var _context$getExtension;\n        var context = this.webGLContexts[id];\n        (_context$getExtension = context.getExtension(\"WEBGL_lose_context\")) === null || _context$getExtension === void 0 || _context$getExtension.loseContext();\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type5 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type5].kill();\n      }\n      for (var _type6 in this.edgePrograms) {\n        this.edgePrograms[_type6].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      return _objectSpread2({}, this.elements);\n    }\n  }]);\n  return Sigma;\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}