{"ast":null,"code":"import { t as toPropertyKey, d as _createClass, a as _classCallCheck, _ as _inherits, b as _callSuper, c as _assertThisInitialized, e as _getPrototypeOf } from './inherits-8fbdedb5.esm.js';\nimport { i as indexToColor, f as floatColor } from './colors-2f6d17f0.esm.js';\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n  var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  var shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(\"loadShader: error while creating the shader\");\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n  return shader;\n}\nfunction loadVertexShader(gl, source) {\n  return loadShader(\"VERTEX\", gl, source);\n}\nfunction loadFragmentShader(gl, source) {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n  var i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n  gl.linkProgram(program);\n\n  // Checking status\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n  return program;\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nfunction numberToGLSLFloat(n) {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\nvar PICKING_PREFIX = \"#define PICKING_MODE\\n\";\nvar SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);\nfunction getAttributeItemsCount(attr) {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs) {\n  var res = 0;\n  attrs.forEach(function (attr) {\n    return res += getAttributeItemsCount(attr);\n  });\n  return res;\n}\nvar AbstractProgram = /*#__PURE__*/_createClass(\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction AbstractProgram(_gl, _pickGl, _renderer) {\n  _classCallCheck(this, AbstractProgram);\n});\nvar Program = /*#__PURE__*/function () {\n  function Program(gl, pickingBuffer, renderer) {\n    _classCallCheck(this, Program);\n    _defineProperty(this, \"array\", new Float32Array());\n    _defineProperty(this, \"constantArray\", new Float32Array());\n    _defineProperty(this, \"capacity\", 0);\n    _defineProperty(this, \"verticesCount\", 0);\n    // Reading and caching program definition\n    var def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer ? this.getProgramInfo(\"pick\", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error(\"Program: error while getting constant data (expected \".concat(this.VERTICES, \" items, received \").concat(this.CONSTANT_DATA.length, \" instead)\"));\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {\n        var vector = this.CONSTANT_DATA[i];\n        if (vector.length !== constantAttributesItemsCount) throw new Error(\"Program: error while getting constant data (one vector has \".concat(vector.length, \" items instead of \").concat(constantAttributesItemsCount, \")\"));\n        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n  _createClass(Program, [{\n    key: \"getProgramInfo\",\n    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {\n      var def = this.getDefinition();\n\n      // WebGL buffers\n      var buffer = gl.createBuffer();\n      if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n      // Shaders and program\n      var vertexShader = loadVertexShader(gl, vertexShaderSource);\n      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n      var program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n      // Initializing locations\n      var uniformLocations = {};\n      def.UNIFORMS.forEach(function (uniformName) {\n        var location = gl.getUniformLocation(program, uniformName);\n        if (location) uniformLocations[uniformName] = location;\n      });\n      var attributeLocations = {};\n      def.ATTRIBUTES.forEach(function (attr) {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      // For instanced programs:\n      var constantBuffer;\n      if (\"CONSTANT_ATTRIBUTES\" in def) {\n        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n        });\n        constantBuffer = gl.createBuffer();\n        if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n      }\n      return {\n        name: name,\n        program: program,\n        gl: gl,\n        frameBuffer: frameBuffer,\n        buffer: buffer,\n        constantBuffer: constantBuffer || {},\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        isPicking: name === \"pick\"\n      };\n    }\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var _this = this;\n      var offset = 0;\n      var gl = program.gl,\n        buffer = program.buffer;\n      if (!this.isInstanced) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      } else {\n        // Handle constant data (things that remain unchanged for all items):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n        offset = 0;\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, false);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n        // Handle \"instance specific\" data (things that vary for each item):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, true);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"unbindProgram\",\n    value: function unbindProgram(program) {\n      var _this2 = this;\n      if (!this.isInstanced) {\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program);\n        });\n      } else {\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, false);\n        });\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, true);\n        });\n      }\n    }\n  }, {\n    key: \"bindAttribute\",\n    value: function bindAttribute(attr, program, offset, setDivisor) {\n      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n      if (typeof sizeFactor !== \"number\") throw new Error(\"Program.bind: yet unsupported attribute type \\\"\".concat(attr.type, \"\\\"\"));\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.enableVertexAttribArray(location);\n        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;\n        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n        if (this.isInstanced && setDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n          }\n        }\n      }\n      return attr.size * sizeFactor;\n    }\n  }, {\n    key: \"unbindAttribute\",\n    value: function unbindAttribute(attr, program, unsetDivisor) {\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.disableVertexAttribArray(location);\n        if (this.isInstanced && unsetDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 0);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(capacity) {\n      // If desired capacity has not changed we do nothing\n      // NOTE: it's possible here to implement more subtle reallocation schemes\n      // when the number of rendered items increase or decrease\n      if (capacity === this.capacity) return;\n      this.capacity = capacity;\n      this.verticesCount = this.VERTICES * capacity;\n      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);\n    }\n  }, {\n    key: \"hasNothingToRender\",\n    value: function hasNothingToRender() {\n      return this.verticesCount === 0;\n    }\n  }, {\n    key: \"renderProgram\",\n    value: function renderProgram(params, programInfo) {\n      var gl = programInfo.gl,\n        program = programInfo.program;\n\n      // With the current fix for #1397, the alpha blending is enabled for the\n      // picking layer:\n      gl.enable(gl.BLEND);\n\n      // Original code:\n      // if (!isPicking) gl.enable(gl.BLEND);\n      // else gl.disable(gl.BLEND);\n\n      gl.useProgram(program);\n      this.setUniforms(params, programInfo);\n      this.drawWebGL(this.METHOD, programInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      if (this.hasNothingToRender()) return;\n      if (this.pickProgram) {\n        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);\n        this.bindProgram(this.pickProgram);\n        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {\n          pixelRatio: params.pixelRatio / params.downSizingRatio\n        }), this.pickProgram);\n        this.unbindProgram(this.pickProgram);\n      }\n      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n      this.bindProgram(this.normalProgram);\n      this.renderProgram(params, this.normalProgram);\n      this.unbindProgram(this.normalProgram);\n    }\n  }, {\n    key: \"drawWebGL\",\n    value: function drawWebGL(method, _ref) {\n      var gl = _ref.gl,\n        frameBuffer = _ref.frameBuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      if (!this.isInstanced) {\n        gl.drawArrays(method, 0, this.verticesCount);\n      } else {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n        } else {\n          var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n        }\n      }\n    }\n  }]);\n  return Program;\n}();\nvar AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  _inherits(AbstractNodeProgram, _AbstractProgram);\n  function AbstractNodeProgram() {\n    _classCallCheck(this, AbstractNodeProgram);\n    return _callSuper(this, AbstractNodeProgram, arguments);\n  }\n  return _createClass(AbstractNodeProgram);\n}(AbstractProgram);\nvar NodeProgram = /*#__PURE__*/function (_ref) {\n  _inherits(NodeProgram, _ref);\n  function NodeProgram() {\n    _classCallCheck(this, NodeProgram);\n    return _callSuper(this, NodeProgram, arguments);\n  }\n  _createClass(NodeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(nodeIndex, offset, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem(indexToColor(nodeIndex), i, data);\n    }\n  }]);\n  return NodeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses, drawLabel, drawHover) {\n  return /*#__PURE__*/function () {\n    function NodeCompoundProgram(gl, pickingBuffer, renderer) {\n      _classCallCheck(this, NodeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      _defineProperty(this, \"drawHover\", drawHover);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    _createClass(NodeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(nodeIndex, offset, data) {\n        this.programs.forEach(function (program) {\n          return program.process(nodeIndex, offset, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return NodeCompoundProgram;\n  }();\n}\nvar AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  _inherits(AbstractEdgeProgram, _AbstractProgram);\n  function AbstractEdgeProgram() {\n    _classCallCheck(this, AbstractEdgeProgram);\n    return _callSuper(this, AbstractEdgeProgram, arguments);\n  }\n  return _createClass(AbstractEdgeProgram);\n}(AbstractProgram);\nvar EdgeProgram = /*#__PURE__*/function (_ref) {\n  _inherits(EdgeProgram, _ref);\n  function EdgeProgram() {\n    var _this;\n    _classCallCheck(this, EdgeProgram);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, EdgeProgram, [].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"drawLabel\", undefined);\n    return _this;\n  }\n  _createClass(EdgeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(edgeIndex, offset, sourceData, targetData, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden || sourceData.hidden || targetData.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem(indexToColor(edgeIndex), i, sourceData, targetData, data);\n    }\n  }]);\n  return EdgeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nfunction createEdgeCompoundProgram(programClasses, drawLabel) {\n  return /*#__PURE__*/function () {\n    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {\n      _classCallCheck(this, EdgeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    _createClass(EdgeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(edgeIndex, offset, sourceData, targetData, data) {\n        this.programs.forEach(function (program) {\n          return program.process(edgeIndex, offset, sourceData, targetData, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return EdgeCompoundProgram;\n  }();\n}\nfunction drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"â€¦\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\nfunction drawDiscNodeLabel(context, data, settings) {\n  if (!data.label) return;\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\" : settings.labelColor.color;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawDiscNodeHover(context, data, settings) {\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n  var PADDING = 2;\n  if (typeof data.label === \"string\") {\n    var textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n    var angleRadian = Math.asin(boxHeight / 2 / radius);\n    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\nuniform float u_correctionRatio;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float border = u_correctionRatio * 2.0;\\n  float dist = length(v_diffVector) - v_radius + border;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > border)\\n    gl_FragColor = transparent;\\n  else\\n    gl_FragColor = v_color;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / border;\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$2 = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"];\nvar NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {\n  _inherits(NodeCircleProgram, _NodeProgram);\n  function NodeCircleProgram() {\n    _classCallCheck(this, NodeCircleProgram);\n    return _callSuper(this, NodeCircleProgram, arguments);\n  }\n  _createClass(NodeCircleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$2,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_angle\",\n          size: 1,\n          type: FLOAT$3\n        }],\n        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      var color = floatColor(data.color);\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = color;\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n  return NodeCircleProgram;\n}(NodeProgram);\n_defineProperty(NodeCircleProgram, \"ANGLE_1\", 0);\n_defineProperty(NodeCircleProgram, \"ANGLE_2\", 2 * Math.PI / 3);\n_defineProperty(NodeCircleProgram, \"ANGLE_3\", 4 * Math.PI / 3);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec3 a_barycentric;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\n#else\\nattribute vec4 a_color;\\n#endif\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (webGLNodeRadius * unitNormal.y)\\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-webGLNodeRadius * unitNormal.x)\\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeArrowHeadProgram = /*#__PURE__*/function (_EdgeProgram) {\n  _inherits(EdgeArrowHeadProgram, _EdgeProgram);\n  function EdgeArrowHeadProgram() {\n    _classCallCheck(this, EdgeArrowHeadProgram);\n    return _callSuper(this, EdgeArrowHeadProgram, arguments);\n  }\n  _createClass(EdgeArrowHeadProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT$2\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_barycentric\",\n          size: 3,\n          type: FLOAT$2\n        }],\n        CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var radius = targetData.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = -n1;\n      array[startIndex++] = -n2;\n      array[startIndex++] = radius;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeArrowHeadProgram;\n}(EdgeProgram);\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 0.001;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  // We only handle antialiasing for normal mode:\\n  #ifdef PICKING_MODE\\n  gl_FragColor = v_color;\\n  #else\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_zoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // We require edges to be at least \\\"minThickness\\\" pixels thick *on screen*\\n  // (so we need to compensate the size ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \\\"magic\\\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \\\"magic\\\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasing effect does not depend on the zoom level. So here's yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  _inherits(EdgeRectangleProgram, _EdgeProgram);\n  function EdgeRectangleProgram() {\n    _classCallCheck(this, EdgeRectangleProgram);\n    return _callSuper(this, EdgeRectangleProgram, arguments);\n  }\n  _createClass(EdgeRectangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT$1\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT$1\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_zoomRatio = uniformLocations.u_zoomRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_sizeRatio = uniformLocations.u_sizeRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeRectangleProgram;\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_radius;\\nattribute float a_radiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float radius = a_radius * a_radiusCoef;\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(radius);\\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar EdgeClampedProgram = /*#__PURE__*/function (_EdgeRectangleProgram) {\n  _inherits(EdgeClampedProgram, _EdgeRectangleProgram);\n  function EdgeClampedProgram() {\n    _classCallCheck(this, EdgeClampedProgram);\n    return _callSuper(this, EdgeClampedProgram, arguments);\n  }\n  _createClass(EdgeClampedProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(EdgeClampedProgram.prototype), \"getDefinition\", this).call(this)), {}, {\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_radiusCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]\n      });\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var radius = targetData.size || 1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n      array[startIndex++] = radius;\n    }\n  }]);\n  return EdgeClampedProgram;\n}(EdgeRectangleProgram);\n\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nvar EdgeArrowProgram = createEdgeCompoundProgram([EdgeClampedProgram, EdgeArrowHeadProgram]);\nvar EdgeArrowProgram$1 = EdgeArrowProgram;\nexport { AbstractNodeProgram as A, EdgeArrowProgram$1 as E, NodeCircleProgram as N, Program as P, _defineProperty as _, _objectSpread2 as a, drawDiscNodeLabel as b, drawDiscNodeHover as c, drawStraightEdgeLabel as d, EdgeRectangleProgram as e, NodeProgram as f, EdgeProgram as g, createNodeCompoundProgram as h, AbstractEdgeProgram as i, createEdgeCompoundProgram as j, AbstractProgram as k, EdgeArrowHeadProgram as l, EdgeClampedProgram as m, loadVertexShader as n, loadFragmentShader as o, loadProgram as p, numberToGLSLFloat as q };","map":{"version":3,"names":["t","toPropertyKey","d","_createClass","a","_classCallCheck","_","_inherits","b","_callSuper","c","_assertThisInitialized","e","_getPrototypeOf","i","indexToColor","f","floatColor","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","r","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","loadShader","type","gl","source","glType","VERTEX_SHADER","FRAGMENT_SHADER","shader","createShader","Error","shaderSource","compileShader","successfullyCompiled","getShaderParameter","COMPILE_STATUS","infoLog","getShaderInfoLog","deleteShader","concat","loadVertexShader","loadFragmentShader","loadProgram","shaders","program","createProgram","l","attachShader","linkProgram","successfullyLinked","getProgramParameter","LINK_STATUS","deleteProgram","numberToGLSLFloat","n","toFixed","toString","PICKING_PREFIX","SIZE_FACTOR_PER_ATTRIBUTE_TYPE","WebGL2RenderingContext","BOOL","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","getAttributeItemsCount","attr","normalized","size","getAttributesItemsCount","attrs","res","AbstractProgram","_gl","_pickGl","_renderer","Program","pickingBuffer","renderer","Float32Array","def","getDefinition","VERTICES","VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","UNIFORMS","ATTRIBUTES","METHOD","CONSTANT_ATTRIBUTES","CONSTANT_DATA","isInstanced","ATTRIBUTES_ITEMS_COUNT","STRIDE","normalProgram","getProgramInfo","pickProgram","constantAttributesItemsCount","constantArray","vector","j","name","vertexShaderSource","fragmentShaderSource","frameBuffer","buffer","createBuffer","vertexShader","fragmentShader","uniformLocations","uniformName","location","getUniformLocation","attributeLocations","getAttribLocation","constantBuffer","isPicking","bindProgram","_this","offset","bindBuffer","ARRAY_BUFFER","bindAttribute","bufferData","array","DYNAMIC_DRAW","STATIC_DRAW","unbindProgram","_this2","unbindAttribute","setDivisor","sizeFactor","enableVertexAttribArray","stride","BYTES_PER_ELEMENT","vertexAttribPointer","vertexAttribDivisor","ext","getExtension","vertexAttribDivisorANGLE","unsetDivisor","disableVertexAttribArray","reallocate","capacity","verticesCount","hasNothingToRender","renderProgram","params","programInfo","enable","BLEND","useProgram","setUniforms","drawWebGL","render","viewport","width","pixelRatio","downSizingRatio","height","method","_ref","bindFramebuffer","FRAMEBUFFER","drawArrays","drawArraysInstanced","drawArraysInstancedANGLE","AbstractNodeProgram","_AbstractProgram","NodeProgram","kill","undefined","process","nodeIndex","data","hidden","processVisibleItem","createNodeCompoundProgram","programClasses","drawLabel","drawHover","NodeCompoundProgram","programs","map","AbstractEdgeProgram","EdgeProgram","_len","args","Array","_key","edgeIndex","sourceData","targetData","createEdgeCompoundProgram","EdgeCompoundProgram","drawStraightEdgeLabel","context","edgeData","settings","edgeLabelSize","font","edgeLabelFont","weight","edgeLabelWeight","color","edgeLabelColor","attribute","label","fillStyle","sSize","tSize","sx","x","sy","y","tx","ty","cx","cy","dx","dy","Math","sqrt","textLength","measureText","ellipsis","slice","angle","acos","asin","PI","save","translate","rotate","fillText","restore","drawDiscNodeLabel","labelSize","labelFont","labelWeight","labelColor","drawDiscNodeHover","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","PADDING","textWidth","boxWidth","round","boxHeight","radius","max","angleRadian","xDeltaCoord","abs","pow","beginPath","moveTo","lineTo","arc","closePath","fill","SHADER_SOURCE$6","FRAGMENT_SHADER_SOURCE$2","SHADER_SOURCE$5","VERTEX_SHADER_SOURCE$3","_WebGLRenderingContex$3","WebGLRenderingContext","UNSIGNED_BYTE$3","FLOAT$3","UNIFORMS$2","NodeCircleProgram","_NodeProgram","TRIANGLES","ANGLE_1","ANGLE_2","ANGLE_3","startIndex","u_sizeRatio","u_correctionRatio","u_matrix","uniform1f","correctionRatio","sizeRatio","uniformMatrix3fv","matrix","SHADER_SOURCE$4","FRAGMENT_SHADER_SOURCE$1","SHADER_SOURCE$3","VERTEX_SHADER_SOURCE$2","_WebGLRenderingContex$2","UNSIGNED_BYTE$2","FLOAT$2","UNIFORMS$1","EdgeArrowHeadProgram","_EdgeProgram","thickness","x1","y1","x2","y2","len","n1","n2","_superPropBase","object","property","prototype","hasOwnProperty","call","_get","Reflect","get","bind","target","receiver","base","desc","SHADER_SOURCE$2","SHADER_SOURCE$1","VERTEX_SHADER_SOURCE$1","_WebGLRenderingContex$1","UNSIGNED_BYTE$1","FLOAT$1","EdgeRectangleProgram","u_zoomRatio","zoomRatio","SHADER_SOURCE","_WebGLRenderingContex","EdgeClampedProgram","_EdgeRectangleProgram","EdgeArrowProgram","EdgeArrowProgram$1","A","E","N","P","g","h","k","m","p","q"],"sources":["C:/ders2/aÄŸ python/sigma/app/application/node_modules/sigma/dist/index-29acc883.esm.js"],"sourcesContent":["import { t as toPropertyKey, d as _createClass, a as _classCallCheck, _ as _inherits, b as _callSuper, c as _assertThisInitialized, e as _getPrototypeOf } from './inherits-8fbdedb5.esm.js';\nimport { i as indexToColor, f as floatColor } from './colors-2f6d17f0.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n  var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  var shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(\"loadShader: error while creating the shader\");\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n  return shader;\n}\nfunction loadVertexShader(gl, source) {\n  return loadShader(\"VERTEX\", gl, source);\n}\nfunction loadFragmentShader(gl, source) {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n  var i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n  gl.linkProgram(program);\n\n  // Checking status\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n  return program;\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nfunction numberToGLSLFloat(n) {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\n\nvar PICKING_PREFIX = \"#define PICKING_MODE\\n\";\nvar SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);\nfunction getAttributeItemsCount(attr) {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs) {\n  var res = 0;\n  attrs.forEach(function (attr) {\n    return res += getAttributeItemsCount(attr);\n  });\n  return res;\n}\nvar AbstractProgram = /*#__PURE__*/_createClass(\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction AbstractProgram(_gl, _pickGl, _renderer) {\n  _classCallCheck(this, AbstractProgram);\n});\nvar Program = /*#__PURE__*/function () {\n  function Program(gl, pickingBuffer, renderer) {\n    _classCallCheck(this, Program);\n    _defineProperty(this, \"array\", new Float32Array());\n    _defineProperty(this, \"constantArray\", new Float32Array());\n    _defineProperty(this, \"capacity\", 0);\n    _defineProperty(this, \"verticesCount\", 0);\n    // Reading and caching program definition\n    var def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer ? this.getProgramInfo(\"pick\", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error(\"Program: error while getting constant data (expected \".concat(this.VERTICES, \" items, received \").concat(this.CONSTANT_DATA.length, \" instead)\"));\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {\n        var vector = this.CONSTANT_DATA[i];\n        if (vector.length !== constantAttributesItemsCount) throw new Error(\"Program: error while getting constant data (one vector has \".concat(vector.length, \" items instead of \").concat(constantAttributesItemsCount, \")\"));\n        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n  _createClass(Program, [{\n    key: \"getProgramInfo\",\n    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {\n      var def = this.getDefinition();\n\n      // WebGL buffers\n      var buffer = gl.createBuffer();\n      if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n      // Shaders and program\n      var vertexShader = loadVertexShader(gl, vertexShaderSource);\n      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n      var program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n      // Initializing locations\n      var uniformLocations = {};\n      def.UNIFORMS.forEach(function (uniformName) {\n        var location = gl.getUniformLocation(program, uniformName);\n        if (location) uniformLocations[uniformName] = location;\n      });\n      var attributeLocations = {};\n      def.ATTRIBUTES.forEach(function (attr) {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      // For instanced programs:\n      var constantBuffer;\n      if (\"CONSTANT_ATTRIBUTES\" in def) {\n        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n        });\n        constantBuffer = gl.createBuffer();\n        if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n      }\n      return {\n        name: name,\n        program: program,\n        gl: gl,\n        frameBuffer: frameBuffer,\n        buffer: buffer,\n        constantBuffer: constantBuffer || {},\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        isPicking: name === \"pick\"\n      };\n    }\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var _this = this;\n      var offset = 0;\n      var gl = program.gl,\n        buffer = program.buffer;\n      if (!this.isInstanced) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      } else {\n        // Handle constant data (things that remain unchanged for all items):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n        offset = 0;\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, false);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n        // Handle \"instance specific\" data (things that vary for each item):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, true);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"unbindProgram\",\n    value: function unbindProgram(program) {\n      var _this2 = this;\n      if (!this.isInstanced) {\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program);\n        });\n      } else {\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, false);\n        });\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, true);\n        });\n      }\n    }\n  }, {\n    key: \"bindAttribute\",\n    value: function bindAttribute(attr, program, offset, setDivisor) {\n      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n      if (typeof sizeFactor !== \"number\") throw new Error(\"Program.bind: yet unsupported attribute type \\\"\".concat(attr.type, \"\\\"\"));\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.enableVertexAttribArray(location);\n        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;\n        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n        if (this.isInstanced && setDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n          }\n        }\n      }\n      return attr.size * sizeFactor;\n    }\n  }, {\n    key: \"unbindAttribute\",\n    value: function unbindAttribute(attr, program, unsetDivisor) {\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.disableVertexAttribArray(location);\n        if (this.isInstanced && unsetDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 0);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(capacity) {\n      // If desired capacity has not changed we do nothing\n      // NOTE: it's possible here to implement more subtle reallocation schemes\n      // when the number of rendered items increase or decrease\n      if (capacity === this.capacity) return;\n      this.capacity = capacity;\n      this.verticesCount = this.VERTICES * capacity;\n      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);\n    }\n  }, {\n    key: \"hasNothingToRender\",\n    value: function hasNothingToRender() {\n      return this.verticesCount === 0;\n    }\n  }, {\n    key: \"renderProgram\",\n    value: function renderProgram(params, programInfo) {\n      var gl = programInfo.gl,\n        program = programInfo.program;\n\n      // With the current fix for #1397, the alpha blending is enabled for the\n      // picking layer:\n      gl.enable(gl.BLEND);\n\n      // Original code:\n      // if (!isPicking) gl.enable(gl.BLEND);\n      // else gl.disable(gl.BLEND);\n\n      gl.useProgram(program);\n      this.setUniforms(params, programInfo);\n      this.drawWebGL(this.METHOD, programInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      if (this.hasNothingToRender()) return;\n      if (this.pickProgram) {\n        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);\n        this.bindProgram(this.pickProgram);\n        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {\n          pixelRatio: params.pixelRatio / params.downSizingRatio\n        }), this.pickProgram);\n        this.unbindProgram(this.pickProgram);\n      }\n      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n      this.bindProgram(this.normalProgram);\n      this.renderProgram(params, this.normalProgram);\n      this.unbindProgram(this.normalProgram);\n    }\n  }, {\n    key: \"drawWebGL\",\n    value: function drawWebGL(method, _ref) {\n      var gl = _ref.gl,\n        frameBuffer = _ref.frameBuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      if (!this.isInstanced) {\n        gl.drawArrays(method, 0, this.verticesCount);\n      } else {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n        } else {\n          var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n        }\n      }\n    }\n  }]);\n  return Program;\n}();\n\nvar AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  _inherits(AbstractNodeProgram, _AbstractProgram);\n  function AbstractNodeProgram() {\n    _classCallCheck(this, AbstractNodeProgram);\n    return _callSuper(this, AbstractNodeProgram, arguments);\n  }\n  return _createClass(AbstractNodeProgram);\n}(AbstractProgram);\nvar NodeProgram = /*#__PURE__*/function (_ref) {\n  _inherits(NodeProgram, _ref);\n  function NodeProgram() {\n    _classCallCheck(this, NodeProgram);\n    return _callSuper(this, NodeProgram, arguments);\n  }\n  _createClass(NodeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(nodeIndex, offset, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem(indexToColor(nodeIndex), i, data);\n    }\n  }]);\n  return NodeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses, drawLabel, drawHover) {\n  return /*#__PURE__*/function () {\n    function NodeCompoundProgram(gl, pickingBuffer, renderer) {\n      _classCallCheck(this, NodeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      _defineProperty(this, \"drawHover\", drawHover);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    _createClass(NodeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(nodeIndex, offset, data) {\n        this.programs.forEach(function (program) {\n          return program.process(nodeIndex, offset, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return NodeCompoundProgram;\n  }();\n}\n\nvar AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  _inherits(AbstractEdgeProgram, _AbstractProgram);\n  function AbstractEdgeProgram() {\n    _classCallCheck(this, AbstractEdgeProgram);\n    return _callSuper(this, AbstractEdgeProgram, arguments);\n  }\n  return _createClass(AbstractEdgeProgram);\n}(AbstractProgram);\nvar EdgeProgram = /*#__PURE__*/function (_ref) {\n  _inherits(EdgeProgram, _ref);\n  function EdgeProgram() {\n    var _this;\n    _classCallCheck(this, EdgeProgram);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, EdgeProgram, [].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"drawLabel\", undefined);\n    return _this;\n  }\n  _createClass(EdgeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(edgeIndex, offset, sourceData, targetData, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden || sourceData.hidden || targetData.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem(indexToColor(edgeIndex), i, sourceData, targetData, data);\n    }\n  }]);\n  return EdgeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nfunction createEdgeCompoundProgram(programClasses, drawLabel) {\n  return /*#__PURE__*/function () {\n    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {\n      _classCallCheck(this, EdgeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    _createClass(EdgeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(edgeIndex, offset, sourceData, targetData, data) {\n        this.programs.forEach(function (program) {\n          return program.process(edgeIndex, offset, sourceData, targetData, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return EdgeCompoundProgram;\n  }();\n}\n\nfunction drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"â€¦\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\n\nfunction drawDiscNodeLabel(context, data, settings) {\n  if (!data.label) return;\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\" : settings.labelColor.color;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawDiscNodeHover(context, data, settings) {\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n  var PADDING = 2;\n  if (typeof data.label === \"string\") {\n    var textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n    var angleRadian = Math.asin(boxHeight / 2 / radius);\n    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\nuniform float u_correctionRatio;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float border = u_correctionRatio * 2.0;\\n  float dist = length(v_diffVector) - v_radius + border;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > border)\\n    gl_FragColor = transparent;\\n  else\\n    gl_FragColor = v_color;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / border;\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$2 = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"];\nvar NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {\n  _inherits(NodeCircleProgram, _NodeProgram);\n  function NodeCircleProgram() {\n    _classCallCheck(this, NodeCircleProgram);\n    return _callSuper(this, NodeCircleProgram, arguments);\n  }\n  _createClass(NodeCircleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$2,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_angle\",\n          size: 1,\n          type: FLOAT$3\n        }],\n        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      var color = floatColor(data.color);\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = color;\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n  return NodeCircleProgram;\n}(NodeProgram);\n_defineProperty(NodeCircleProgram, \"ANGLE_1\", 0);\n_defineProperty(NodeCircleProgram, \"ANGLE_2\", 2 * Math.PI / 3);\n_defineProperty(NodeCircleProgram, \"ANGLE_3\", 4 * Math.PI / 3);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec3 a_barycentric;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\n#else\\nattribute vec4 a_color;\\n#endif\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (webGLNodeRadius * unitNormal.y)\\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-webGLNodeRadius * unitNormal.x)\\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeArrowHeadProgram = /*#__PURE__*/function (_EdgeProgram) {\n  _inherits(EdgeArrowHeadProgram, _EdgeProgram);\n  function EdgeArrowHeadProgram() {\n    _classCallCheck(this, EdgeArrowHeadProgram);\n    return _callSuper(this, EdgeArrowHeadProgram, arguments);\n  }\n  _createClass(EdgeArrowHeadProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT$2\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_barycentric\",\n          size: 3,\n          type: FLOAT$2\n        }],\n        CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var radius = targetData.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = -n1;\n      array[startIndex++] = -n2;\n      array[startIndex++] = radius;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeArrowHeadProgram;\n}(EdgeProgram);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 0.001;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  // We only handle antialiasing for normal mode:\\n  #ifdef PICKING_MODE\\n  gl_FragColor = v_color;\\n  #else\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_zoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // We require edges to be at least \\\"minThickness\\\" pixels thick *on screen*\\n  // (so we need to compensate the size ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \\\"magic\\\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \\\"magic\\\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasing effect does not depend on the zoom level. So here's yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  _inherits(EdgeRectangleProgram, _EdgeProgram);\n  function EdgeRectangleProgram() {\n    _classCallCheck(this, EdgeRectangleProgram);\n    return _callSuper(this, EdgeRectangleProgram, arguments);\n  }\n  _createClass(EdgeRectangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT$1\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT$1\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_zoomRatio = uniformLocations.u_zoomRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_sizeRatio = uniformLocations.u_sizeRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeRectangleProgram;\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_radius;\\nattribute float a_radiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float radius = a_radius * a_radiusCoef;\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(radius);\\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar EdgeClampedProgram = /*#__PURE__*/function (_EdgeRectangleProgram) {\n  _inherits(EdgeClampedProgram, _EdgeRectangleProgram);\n  function EdgeClampedProgram() {\n    _classCallCheck(this, EdgeClampedProgram);\n    return _callSuper(this, EdgeClampedProgram, arguments);\n  }\n  _createClass(EdgeClampedProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(EdgeClampedProgram.prototype), \"getDefinition\", this).call(this)), {}, {\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_radiusCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]\n      });\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var radius = targetData.size || 1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n      array[startIndex++] = radius;\n    }\n  }]);\n  return EdgeClampedProgram;\n}(EdgeRectangleProgram);\n\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nvar EdgeArrowProgram = createEdgeCompoundProgram([EdgeClampedProgram, EdgeArrowHeadProgram]);\nvar EdgeArrowProgram$1 = EdgeArrowProgram;\n\nexport { AbstractNodeProgram as A, EdgeArrowProgram$1 as E, NodeCircleProgram as N, Program as P, _defineProperty as _, _objectSpread2 as a, drawDiscNodeLabel as b, drawDiscNodeHover as c, drawStraightEdgeLabel as d, EdgeRectangleProgram as e, NodeProgram as f, EdgeProgram as g, createNodeCompoundProgram as h, AbstractEdgeProgram as i, createEdgeCompoundProgram as j, AbstractProgram as k, EdgeArrowHeadProgram as l, EdgeClampedProgram as m, loadVertexShader as n, loadFragmentShader as o, loadProgram as p, numberToGLSLFloat as q };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}